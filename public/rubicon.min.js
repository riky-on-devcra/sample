(function () {
  const e = {
    locale: (window.rubiconSetting && window.rubiconSetting.locale) || "en",
    environment:
      (window.rubiconSetting && window.rubiconSetting.environment) || "devcra",
    type: (window.rubiconSetting && window.rubiconSetting.type) || "sidepanel",
    showButton:
      (window.rubiconSetting && window.rubiconSetting.showButton) || false,
    options: (window.rubiconSetting && window.rubiconSetting.options) || {
      width: 380,
      height: 600,
      buttonRight: 20,
      buttonBottom: 80,
    },
  };
  console.log("[RUBICON] rubiconConfig", e);
  const t = 375;
  const o = e.options.width || 380;
  const n = e.options.height || 600;
  const i = e.options.right || 32;
  const r = e.options.bottom || 146;
  const s = e.options.borderRadius || 8;
  const c = e.options.boxShadow || "0 4px 12px rgba(0, 0, 0, 0.15)";
  const l = e.showButton || false;
  const a = "0.4s";
  const d = "cubic-bezier(0.4, 0, 0.2, 1)";
  const u = "https://dev-aibot-kr.samsung.com";
  const g = "https://dev-aibot-kr.samsung.com";
  const p = [g];
  const m = [
    ...p,
    "https://p6-pre-qa3.samsung.com",
    "https://dev-www.samsung.com",
    "https://stg-www.samsung.com",
    "https://stg2-www.samsung.com",
    "https://dev-familynet.samsung.com",
    "https://dev-familynet-epp.samsung.com",
    "https://dev-www.familynet.kr",
    "https://dev-familynet.samsung.com",
    "https://stg-familynet.samsung.com",
    "https://samsung.com",
  ];
  var f = false;
  var w, b, h;
  const y = new Set();
  function C(e) {
    try {
      return document.evaluate(
        e,
        document,
        null,
        XPathResult.FIRST_ORDERED_NODE_TYPE,
        null,
      ).singleNodeValue;
    } catch (t) {
      console.error("[RUBICON] Failed to get element by xpath:", e, t);
      return null;
    }
  }
  function I() {
    if (e.type === "sidepanel") {
      x();
    } else if (e.type === "embedded") {
      U();
    }
  }
  function R(t = false) {
    console.log("[RUBICON] _toggleRubicon", { skipAnimation: t });
    if (window.rubicon?.logger) {
      window.rubicon.logger.log("[RUBICON] _toggleRubicon", {
        skipAnimation: t,
      });
    }
    if (e.type === "sidepanel") {
      O(t);
    } else if (e.type === "embedded") {
      N(t);
    }
  }
  function O(e = false) {
    if (f) {
      x();
    } else {
      B(e);
    }
  }
  function B(e = false) {
    f = true;
    if (document.getElementById("main-content")) return;
    w = document.createElement("div");
    w.id = "main-content";
    w.style.height = "100vh";
    w.style.overflowY = "auto";
    w.style.width = "calc(100% - " + t + "px)";
    w.style.transition = e ? "none" : "width " + a + " " + d;
    w.style.position = "relative";
    while (document.body.firstChild && document.body.firstChild !== b) {
      w.appendChild(document.body.firstChild);
    }
    document.body.appendChild(w);
    b = document.createElement("div");
    b.id = "aibot-wrapper";
    b.style.position = "fixed";
    b.style.top = "0";
    b.style.right = "0";
    b.style.height = "100vh";
    b.style.width = t + "px";
    b.style.transform = "translateX(100%)";
    b.style.transition = e ? "none" : "transform " + a + " " + d;
    b.style.overflowY = "hidden";
    b.style.zIndex = "2147484001";
    var o = document.createElement("iframe");
    o.src = L(e);
    o.style.width = "100%";
    o.style.height = "100%";
    o.style.border = "none";
    b.appendChild(o);
    document.body.appendChild(b);
    h = document.createElement("div");
    h.id = "aibot-divider";
    h.style.position = "fixed";
    h.style.top = "0";
    h.style.right = t + "px";
    h.style.width = "2px";
    h.style.height = "100vh";
    h.style.backgroundColor = "#ccc";
    h.style.zIndex = "9998";
    document.body.appendChild(h);
    if (e) {
      b.style.transform = "translateX(0)";
    } else {
      setTimeout(function () {
        b.style.transform = "translateX(0)";
      }, 10);
    }
  }
  function x() {
    f = false;
    b.style.transform = "translateX(100%)";
    h.remove();
    setTimeout(function () {
      while (w.firstChild) {
        document.body.insertBefore(w.firstChild, w);
      }
      w.remove();
      b.remove();
    }, 400);
  }
  function N({ skipAnimation: e = false }) {
    if (b && b.dataset.toggling === "true") {
      return;
    }
    if (f) {
      U();
    } else {
      v(e);
    }
  }
  function v(e = false) {
    f = true;
    if (document.getElementById("aibot-wrapper")) {
      b = document.getElementById("aibot-wrapper");
      b.dataset.toggling = "true";
      b.style.display = "block";
      b.getBoundingClientRect();
      b.style.opacity = "1";
      b.style.transform = "translateY(0)";
      setTimeout(() => {
        b.dataset.toggling = "false";
      }, 400);
      return;
    }
    b = document.createElement("div");
    b.id = "aibot-wrapper";
    b.dataset.toggling = "true";
    b.style.position = "fixed";
    b.style.width = o + "px";
    b.style.height = n + "px";
    b.style.borderRadius = s + "px";
    b.style.boxShadow = c;
    b.style.zIndex = "2147484001";
    b.style.overflow = "hidden";
    b.style.transition = e ? "none" : "opacity " + a + " " + d;
    b.style.bottom = r + "px";
    b.style.right = i + "px";
    b.style.transform = "translateY(calc(100% + " + r + "px))";
    var t = document.createElement("iframe");
    t.src = L(e);
    t.style.width = "100%";
    t.style.height = "100%";
    t.style.border = "none";
    b.appendChild(t);
    document.body.appendChild(b);
    if (e) {
      b.style.opacity = "1";
      b.style.transform = "translateY(0)";
      b.dataset.toggling = "false";
    } else {
      b.getBoundingClientRect();
      setTimeout(function () {
        b.style.opacity = "1";
        b.style.transform = "translateY(0)";
        setTimeout(() => {
          b.dataset.toggling = "false";
        }, 400);
      }, 10);
    }
  }
  function U() {
    f = false;
    if (!b) return;
    b.dataset.toggling = "true";
    b.style.opacity = "0";
    b.style.transform = position.startsWith("bottom")
      ? "translateY(calc(100% + 100px))"
      : "translateY(calc(-100% - 100px))";
    setTimeout(function () {
      b.style.display = "none";
      b.dataset.toggling = "false";
    }, 400);
  }
  function S() {
    console.log("[RUBICON] _createButtonIfNeeded");
    if (l) {
      const o = e.options.buttonRight || 20;
      const n = e.options.buttonBottom || 80;
      buttonWrapper = document.createElement("div");
      buttonWrapper.innerHTML = E();
      buttonWrapper.style.position = "fixed";
      buttonWrapper.style.bottom = n + "px";
      buttonWrapper.style.right = o + "px";
      buttonWrapper.style.zIndex = "2147484001";
      var t =
        buttonWrapper.querySelector("button") ||
        buttonWrapper.querySelector("a");
      document.body.appendChild(buttonWrapper);
      t.onclick = () => R(false);
    }
  }
  function E() {
    return (
      "<div>" +
      '<button style="width: 48px; height: 48px; border-radius: 50%; background: #0071e3; color: white; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">' +
      '<span class="sr-only">ë£¨ë¹„ì½˜ ë²„íŠ¼</span>' +
      "ðŸ¤–" +
      "</button>" +
      "</div>"
    );
  }
  function k() {
    console.log("[RUBICON] initRubicon", { rubiconConfig: e });
    if (window.rubicon?.logger) {
      window.rubicon.logger.log("[RUBICON] initRubicon", { rubiconConfig: e });
    }
    S();
    const t = window.aisearch?.nlq;
    if (typeof t === "object" && t?.flag === true && t.query) {
      console.log(
        "[RUBICON] aisearch-v2 nlq flag is true",
        window.aisearch.nlq,
      );
      window.rubicon.openRubicon(window.aisearch.nlq.query);
      return;
    }
    const o = localStorage.getItem("rubicon-pending-iframe") === "1";
    if (o && !f) {
      R(true);
      localStorage.removeItem("rubicon-pending-iframe");
    }
    for (let e = 0; e < localStorage.length; e++) {
      const t = localStorage.key(e);
      if (t && t.startsWith("rubicon-actions:")) {
        console.log("[RUBICON] found actions:", t);
        if (window.rubicon?.logger) {
          window.rubicon.logger.log("[RUBICON] found actions:", t);
        }
        const e = t.split(":")[1];
        window.rubicon.consumeActions(e);
      }
    }
  }
  window.addEventListener("message", function (e) {
    if (!e || !e.data) return;
    const { type: t, method: o, args: n } = e.data;
    if (!p.includes(e.origin)) return;
    console.log("[RUBICON] received message:", e.origin, e.data);
    if (window.rubicon?.logger) {
      window.rubicon.logger.log(
        "[RUBICON] received message:",
        e.origin,
        e.data,
      );
    }
    if (
      t === "rubicon-command" &&
      window.rubicon &&
      typeof window.rubicon[o] === "function"
    ) {
      try {
        console.log(
          `[RUBICON] iframe command: rubicon.${o}(${(n || []).join(", ")})`,
        );
        try {
          const t = window.rubicon[o](...(n || []));
          if (t instanceof Promise) {
            t.then((t) => {
              e.source.postMessage(
                {
                  type: "rubicon-response",
                  method: o,
                  requestId: e.data.requestId,
                  result: t,
                },
                e.origin,
              );
            }).catch((t) => {
              e.source.postMessage(
                {
                  type: "rubicon-response",
                  method: o,
                  requestId: e.data.requestId,
                  error: String(t),
                },
                e.origin,
              );
            });
          } else {
            e.source.postMessage(
              {
                type: "rubicon-response",
                method: o,
                requestId: e.data.requestId,
                result: t,
              },
              e.origin,
            );
          }
        } catch (e) {
          console.error("[RUBICON] Execution error:", e);
        }
      } catch (e) {
        console.error("[RUBICON] Command failed:", o, e);
      }
    }
  });
  function A() {
    return e.locale === "ko" ? g : RUBICON_UK_ORIGIN;
  }
  function L(t = false) {
    const o = (e.locale === "ko" ? u : RUBICON_UK_URL) + `${t ? "" : ""}`;
    console.log("[RUBICON] RubiconEndpoint", o);
    return o;
  }
  const T = (e) => {
    const t = document.getElementById("aibot-wrapper")?.querySelector("iframe");
    if (!t) {
      console.warn("[RUBICON] iframe not found when trying to send message");
      return;
    }
    console.log("[RUBICON] sending send-message:", e);
    if (window.rubicon?.logger) {
      window.rubicon.logger.log("[RUBICON] sending send-message:", e);
    }
    t.contentWindow?.postMessage({ type: "send-message", data: e }, A());
  };
  function q({ selector: e, xpath: t, timeout: o = 5e3, interval: n = 200 }) {
    return new Promise((i, r) => {
      const s = Date.now();
      function c() {
        let l = e ? document.querySelector(e) : null;
        if (!l && t) l = C(t);
        if (l) return i(l);
        if (Date.now() - s > o) return r(new Error("Element not found"));
        setTimeout(c, n);
      }
      c();
    });
  }
  window.rubicon = {
    getMetadata: () => {
      const e = window.location.href;
      const t = document.getElementById("main-content");
      const o = t ? t.innerHTML : null;
      return { currentUrl: e, currentHtml: o };
    },
    takeSnapshot: () =>
      new Promise((e, t) => {
        function o() {
          return new Promise((e, t) => {
            if (typeof html2canvas !== "undefined") return e();
            const o = document.createElement("script");
            o.src =
              "https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js";
            o.onload = e;
            o.onerror = t;
            document.head.appendChild(o);
          });
        }
        o()
          .then(() => {
            const o = document.getElementById("main-content") || document.body;
            html2canvas(o, {
              useCORS: true,
              allowTaint: true,
              logging: false,
              windowWidth: document.documentElement.scrollWidth,
              windowHeight: document.documentElement.scrollHeight,
            })
              .then((t) => {
                const o = t.toDataURL("image/png");
                e(o);
              })
              .catch((e) => {
                t(e);
              });
          })
          .catch(t);
      }),
    toggleRubicon: () => R(false),
    openSprChat: () => {
      R(false);
      window.sprChat("open");
    },
    openRubicon: (e) => {
      console.log("[RUBICON] openRubicon", { initialMessage: e });
      const t = (o) => {
        if (o.data?.type === "rubicon-ready" && m.includes(o.origin)) {
          console.log("[RUBICON] iframe reported ready, sending message");
          if (window.rubicon?.logger) {
            window.rubicon.logger.log(
              "[RUBICON] iframe reported ready, sending message",
            );
          }
          window.removeEventListener("message", t);
          T(e);
        }
      };
      if (!f) {
        if (e) {
          window.addEventListener("message", t);
          const e = new MutationObserver(() => {
            const t = document
              .getElementById("aibot-wrapper")
              ?.querySelector("iframe");
            if (t) {
              e.disconnect();
              t.onload = () => {
                console.log("[RUBICON] iframe loaded (onload)");
                if (window.rubicon?.logger) {
                  window.rubicon.logger.log("[RUBICON] iframe loaded (onload)");
                }
              };
            }
          });
          e.observe(document.body, { childList: true, subtree: true });
        }
        R(e ? true : false);
      }
    },
    closeRubicon: () => {
      console.log("[RUBICON] closeRubicon");
      if (window.rubicon?.logger) {
        window.rubicon.logger.log("[RUBICON] closeRubicon");
      }
      I();
    },
    canAskRubicon: () => {
      if (f) {
        return true;
      }
      return false;
    },
    askRubicon: (e) => {
      if (window.rubicon.canAskRubicon()) {
        T(e);
      }
    },
    addActions: (e, t, o = false) => {
      console.log("[RUBICON] addActions", { id: e, actions: t, autoRun: o });
      if (window.rubicon?.logger) {
        window.rubicon.logger.log("[RUBICON] addActions", {
          id: e,
          actions: t,
          autoRun: o,
        });
      }
      if (typeof e === "string" && Array.isArray(t)) {
        try {
          localStorage.setItem(`rubicon-actions:${e}`, JSON.stringify(t));
          if (o) {
            window.rubicon.consumeActions(e);
          }
        } catch (e) {
          console.error("[RUBICON] Failed to store actions:", e);
        }
      }
    },
    consumeActions: (e) => {
      console.log("[RUBICON] consumeActions", { id: e });
      if (window.rubicon?.logger) {
        window.rubicon.logger.log("[RUBICON] consumeActions", { id: e });
      }
      if (y.has(e)) return;
      const t = localStorage.getItem(`rubicon-actions:${e}`);
      if (!t) return;
      const o = JSON.parse(t);
      if (!o.length) return;
      if (!f) {
        R(true);
      }
      y.add(e);
      const n = () => {
        const t = o.shift();
        if (!t) {
          localStorage.removeItem(`rubicon-actions:${e}`);
          y.delete(e);
          return;
        }
        localStorage.setItem(`rubicon-actions:${e}`, JSON.stringify(o));
        console.log("[RUBICON] consumeActions", { current: t });
        if (window.rubicon?.logger) {
          window.rubicon.logger.log("[RUBICON] consumeActions", { current: t });
        }
        try {
          switch (t.action) {
            case "GO_TO":
              if (t.value) {
                setTimeout(() => {
                  window.location.href = t.value;
                }, 100);
                if (o.length === 0) {
                  localStorage.setItem("rubicon-pending-iframe", "1");
                }
                return;
              }
              break;
            case "CLICK": {
              q({ selector: t.selector, xpath: t.xpath })
                .then((e) => {
                  try {
                    e.click();
                    console.log(
                      `[RUBICON] CLICK action succeeded: selector=${
                        t.selector || t.xpath
                      }`,
                    );
                    if (window.rubicon?.logger) {
                      window.rubicon.logger.log(
                        `[RUBICON] CLICK action succeeded: selector=${
                          t.selector || t.xpath
                        }`,
                      );
                    }
                    if (o.length === 0) {
                      localStorage.setItem("rubicon-pending-iframe", "1");
                    }
                  } catch (e) {
                    console.warn(
                      `[RUBICON] CLICK action failed (exception): selector=${
                        t.selector || t.xpath
                      }`,
                      e,
                    );
                  }
                  setTimeout(n, 500);
                })
                .catch((e) => {
                  console.warn(
                    `[RUBICON] CLICK action failed (not found): selector=${
                      t.selector || t.xpath
                    }`,
                    e,
                  );
                  setTimeout(n, 500);
                });
              return;
            }
            case "SCROLL": {
              q({ selector: t.selector, xpath: t.xpath })
                .then((e) => {
                  try {
                    e.scrollIntoView({ behavior: "smooth", block: "center" });
                    console.log(
                      `[RUBICON] SCROLL action succeeded: selector=${
                        t.selector || t.xpath
                      }`,
                    );
                    const o = new IntersectionObserver((e, t) => {
                      const o = e.some((e) => e.isIntersecting);
                      if (o) {
                        t.disconnect();
                        setTimeout(n, 200);
                      }
                    });
                    o.observe(e);
                  } catch (e) {
                    console.warn(
                      `[RUBICON] SCROLL action failed (exception): selector=${
                        t.selector || t.xpath
                      }`,
                      e,
                    );
                    setTimeout(n, 500);
                  }
                })
                .catch((e) => {
                  console.warn(
                    `[RUBICON] SCROLL action failed (not found): selector=${
                      t.selector || t.xpath
                    }`,
                    e,
                  );
                  setTimeout(n, 500);
                });
              return;
            }
            default:
              console.warn("Unknown action type:", t.action);
          }
          console.log("[RUBICON] consumed action", t.action);
          if (window.rubicon?.logger) {
            window.rubicon.logger.log("[RUBICON] consumed action", t.action);
          }
        } catch (e) {
          console.error("[RUBICON] Action execution failed:", e);
        }
        if (o.length > 0) return setTimeout(n, 500);
        localStorage.removeItem(`rubicon-actions:${e}`);
        y.delete(e);
      };
      setTimeout(n, 1e3);
    },
    inspectActions: () => {
      const e = [];
      for (let t = 0; t < localStorage.length; t++) {
        const o = localStorage.key(t);
        if (o && o.startsWith("rubicon-actions:")) {
          try {
            const t = JSON.parse(localStorage.getItem(o));
            e.push({ id: o.split(":")[1], actions: t });
          } catch (e) {
            console.error("[RUBICON] Failed to parse:", o, e);
          }
        }
      }
      console.log("[RUBICON] inspectActions", { entries: e });
      if (window.rubicon?.logger) {
        window.rubicon.logger.log("[RUBICON] inspectActions", { entries: e });
      }
    },
    clearActions: () => {
      console.log("[RUBICON] clearActions");
      if (window.rubicon?.logger) {
        window.rubicon.logger.log("[RUBICON] clearActions");
      }
      const e = [];
      for (let t = 0; t < localStorage.length; t++) {
        const o = localStorage.key(t);
        if (o && o.startsWith("rubicon-actions:")) {
          e.push(o);
        }
      }
      e.forEach((e) => localStorage.removeItem(e));
      console.log(`[RUBICON] Cleared ${e.length} action(s):`, e);
      if (window.rubicon?.logger) {
        window.rubicon.logger.log(
          `[RUBICON] Cleared ${e.length} action(s):`,
          e,
        );
      }
    },
    logger: (function () {
      const e = document.createElement("div");
      e.id = "rubicon-logger";
      e.style.cssText = `\n        position: fixed;\n        top: 8px;\n        left: 8px;\n        width: 300px;\n        min-width: 240px;\n        max-width: 360px;\n        max-height: 300px;\n        overflow-y: auto;\n        z-index: 2147483647;\n        background: rgba(0, 0, 0, 0.85);\n        color: #0f0;\n        font-family: monospace;\n        font-size: 10px;\n        padding: 8px;\n        border-radius: 4px;\n        box-shadow: 0 0 4px rgba(0,0,0,0.6);\n        display: none;\n        white-space: pre-wrap;\n      `;
      document.body.appendChild(e);
      return {
        show() {
          e.style.display = "block";
        },
        hide() {
          e.style.display = "none";
        },
        log(...t) {
          const o = document.createElement("div");
          o.textContent = t
            .map((e) => {
              if (e === window.rubicon) {
                return "[RUBICON] window.rubicon object";
              }
              if (typeof e === "object" && e !== null) {
                try {
                  return JSON.stringify(e, null, 2);
                } catch (t) {
                  console.error("[RUBICON] Failed to stringify:", e, t);
                  return String(e);
                }
              }
              return String(e);
            })
            .join(" ");
          e.appendChild(o);
          e.scrollTop = e.scrollHeight;
        },
      };
    })(),
  };
  if (document.readyState === "loading") {
    window.addEventListener("DOMContentLoaded", k);
  } else {
    k();
  }
})();
